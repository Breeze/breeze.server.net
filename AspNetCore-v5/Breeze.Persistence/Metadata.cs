using Breeze.Core;
using System;
using System.Collections.Generic;
using System.Text;

namespace Breeze.Persistence {
  /// <summary> Metadata structure sent to the client </summary>
  public class BreezeMetadata {
    /// <summary> Version of the metadata schema </summary>
    public string MetadataVersion { get; set; }
    /// <summary> Strategy for converting names between client and server </summary>
    public string NamingConvention { get; set; }
    /// <summary> Entity types and Complex types </summary>
    public List<MetaType> StructuralTypes { get; set; }
    /// <summary> Enum types used by entities and complex types </summary>
    public List<MetaEnum> EnumTypes { get; set; }
  }

  /// <summary> Represents a C# enum type, which can be a value for a DataProperty </summary>
  public class MetaEnum {
    /// <summary> Name of the enum </summary>
    public string ShortName { get; set; }
    /// <summary> Namespace of the enum </summary>
    public string Namespace { get; set; }
    /// <summary> String values of the enum </summary>
    public string[] Values { get; set; }
    /// <summary> Int values of the enum </summary>
    public int[] Ordinals { get; set; }
  }

  /// <summary> EntityType or ComplexType </summary>
  public class MetaType {
    /// <summary> Initialize lists </summary>
    public MetaType() {
      DataProperties = new List<MetaDataProperty>();
      NavigationProperties = new List<MetaNavProperty>();
    }
    /// <summary> Name of the type </summary>
    public string ShortName { get; set; }
    /// <summary> Namespace of the type </summary>
    public string Namespace { get; set; }
    /// <summary> Base class, in the form TypeName:#Namespace </summary>
    public string BaseTypeName { get; set; }
    /// <summary> Type of server-generated key for this entity, if any </summary>
    public AutoGeneratedKeyType? AutoGeneratedKeyType { get; set; }
    /// <summary> Name of resource or endpoint on the server for retrieving instances of this entity </summary>
    public string DefaultResourceName { get; set; }
    /// <summary> Whether this type is an abstract base class </summary>
    public bool IsAbstract { get; set; }
    /// <summary> Whether this type is a ComplexType (vs. an Entity) </summary>
    public bool IsComplexType { get; set; }
    /// <summary> Data properties of this type </summary>
    public List<MetaDataProperty> DataProperties { get; set; }
    /// <summary> Navigation properties of this type </summary>
    public List<MetaNavProperty> NavigationProperties { get; set; }
  }

  /// <summary> Base class for Data and Navigation properties </summary>
  public class MetaProperty {

    private List<MetaValidator> _validators = new List<MetaValidator>();

    /// <summary> Arbitrary user-defined object to be set on property metadata </summary>
    public object Custom { get; set; }

    /// <summary> Server version of the property name </summary>
    public string NameOnServer { get; set; }

    /// <summary> Predefined validators applied to this property </summary>
    public List<MetaValidator> Validators {
      get { return _validators; }
    }

  }

  /// <summary> Data Property </summary>
  public class MetaDataProperty : MetaProperty {
    /// <summary> Type of the property: String, Int32, etc. </summary>
    public string DataType { get; set; }
    /// <summary> If an enum, the Name:#NameSpace of the enum type </summary>
    public string EnumType { get; set; }
    /// <summary> Whether property is a part of the entity key </summary>
    public bool? IsPartOfKey { get; set; }
    /// <summary> Whether property is nullable </summary>
    public bool? IsNullable { get; set; }
    /// <summary> If a string, max length allowed </summary>
    public int? MaxLength { get; set; }
    /// <summary> Default value, if defined </summary>
    public Object DefaultValue { get; set; }
    /// <summary> "Fixed" if this property is used as a concurrency token </summary>
    public string ConcurrencyMode { get; set; }
    /// <summary> If a complex object, the Name:#NameSpace of the complex type </summary>
    public string ComplexTypeName { get; set; }
    /// <summary> Used with 'Undefined' DataType </summary>
    public string RawTypeName { get; set; }

    /// <summary> Whether property is an auto-generated key </summary>
    [NonSerialized]
    public bool IsIdentityColumn;
    /// <summary> Add validator names to the property; these match validators on the client </summary>
    public void AddValidators(Type clrType) {
      if (!(this.IsNullable ?? false)) {
        Validators.Add(MetaValidator.Required);
      }
      if (this.MaxLength != null) {
        Validators.Add(new MaxLengthMetaValidator(this.MaxLength.Value));
      }
      var validator = MetaValidator.FindValidator(TypeFns.GetNonNullableType(clrType));
      if (validator != null) {
        Validators.Add(validator);
      }

    }
  }

  /// <summary> Navigation Property </summary>
  public class MetaNavProperty : MetaProperty {
    /// <summary> Name of related entity </summary>
    public string EntityTypeName { get; set; }
    /// <summary> Whether this property returns a single entity (vs. an array of entities) </summary>
    public bool IsScalar { get; set; }
    /// <summary> Unique name of association between entities </summary>
    public string AssociationName { get; set; }
    /// <summary> Names of the foreign key DataProperties associated with this NavigationProperty on this entity </summary>
    public List<String> ForeignKeyNamesOnServer { get; set; }
    /// <summary> Names of the foreign key DataProperties associated with this NavigationProperty on the related entities </summary>
    public List<String> InvForeignKeyNamesOnServer { get; set; }
  }

  /// <summary> Validators for data types </summary>
  public class MetaValidator {
    /// <summary> Set the name </summary>
    public MetaValidator(String name) {
      Name = name;
    }
    /// <summary> Validator for not-null properties </summary>
    public static MetaValidator Required = new MetaValidator("required");

    private static Dictionary<Type, MetaValidator> __validatorMap = new Dictionary<Type, MetaValidator>() {
      { typeof(DateTime), new MetaValidator("date") },
      { typeof(DateTimeOffset), new MetaValidator("date") },
      { typeof(Byte), new MetaValidator("byte") },
      { typeof(Int16), new MetaValidator("int16") },
      { typeof(Int32), new MetaValidator("int32") },
      { typeof(Int64), new MetaValidator("int64") },
      { typeof(Single), new MetaValidator("number") },
      { typeof(Double), new MetaValidator("number") },
      { typeof(Decimal), new MetaValidator("number") },
      { typeof(Boolean), new MetaValidator("bool") },
      { typeof(Guid), new MetaValidator("guid") },
      { typeof(TimeSpan), new MetaValidator("duration") },

    };
    /// <summary> Find the validator for the given type </summary>
    public static MetaValidator FindValidator(Type type) {
      MetaValidator validator = null;
      __validatorMap.TryGetValue(type, out validator);
      return validator;
    }
    /// <summary> Name of the validator </summary>
    public string Name { get; set; }
  }

  /// <summary> Validator for the maximum length of a string </summary>
  public class MaxLengthMetaValidator : MetaValidator {
    /// <summary> Maximum length of string </summary>
    public int MaxLength { get; set; }
    /// <summary> Set the maxlength </summary>
    public MaxLengthMetaValidator(int maxLength) : base("maxLength") {
      MaxLength = maxLength;
    }
  }
}
